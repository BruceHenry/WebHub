### Generator 函数的异步应用
[教程地址：Generator 函数的异步应用](http://es6.ruanyifeng.com/#docs/generator-async)

---
### 目录
```
1. 传统方法
2. 基本概念
3. Generator 函数
4. Thunk 函数
5. co 模块
```

---
### 1. 传统方法
- ES6 诞生以前，异步编程的方法，大概有下面四种
	- 回调函数
	- 事件监听
	- 发布/订阅
	- Promise 对象

---
### 2. 基本概念
- JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是"重新调用"
- 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段
- Promise 对象就是为了解决回调函数地狱而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件
- 可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意
- Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚


---
### 3. Generator 函数
- Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）
- 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明
- Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制
- next返回值的value属性，是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据
- Generator 函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的

---
### 4. Thunk 函数
- Thunk 函数是自动执行 Generator 函数的一种方法
- JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数
- 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式
- Thunk 函数真正的威力，在于可以自动执行 Generator 函数

---
### 5. co 模块
- co 模块是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行
-  模块可以让你不用编写 Generator 函数的执行器,Generator 函数只要传入co函数，就会自动执行
-  co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步


