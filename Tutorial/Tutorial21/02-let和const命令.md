### let和const命令
[教程地址：let和const命令](http://es6.ruanyifeng.com/#docs/let)

---
### 目录
```
1. let命令
2. 块级作用域
3. const命令
4. 顶层对象的属性
5. global 对象
```

---
### 1. let命令
- ES6新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效
- `for`循环的计数器，就很合适使用`let`命令
- `let`不像`var`那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错
- 只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响
- ES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）
- “暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作,在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了,这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错
- let不允许在相同作用域内，重复声明同一个变量,因此，不能在函数内部重新声明参数
- 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了

---
### 2. 块级作用域

- ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数
- ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用
- 另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

---
### 3. const命令
- `const`声明一个只读的常量。一旦声明，常量的值就不能改变
- `const`声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值
- `const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效
- `const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用
- `const`声明的常量，也与`let`一样不可重复声明
- 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。`const`命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心
- 如果真的想将对象冻结，应该使用`Object.freeze`方法
- ES5只有两种声明变量的方法：`var`命令和`function`命令。ES6除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6一共有6种声明变量的方法

---
### 4. 顶层对象的属性
- 顶层对象，在浏览器环境指的是`window`对象，在Node指的是`global`对象。ES5之中，顶层对象的属性与全局变量是等价的
- ES6为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩

---
### 5. global 对象
- ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的
  - 浏览器里面，顶层对象是`window`，但 Node 和 Web Worker 没有`window`
  - 浏览器和 Web Worker 里面，`self`也指向顶层对象，但是Node没有`self`
  - Node 里面，顶层对象是`global`，但其他环境都不支持

- 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用`this`变量，但是有局限性
  - 全局环境中，`this`会返回顶层对象。但是，Node模块和ES6模块中，`this`返回的是当前模块
  - 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`
  - 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么`eval`、`new Function`这些方法都可能无法使用

- 现在有一个提案，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象
- 垫片库[`system.global`](https://github.com/ljharb/System.global)模拟了这个提案，可以在所有环境拿到`global`
