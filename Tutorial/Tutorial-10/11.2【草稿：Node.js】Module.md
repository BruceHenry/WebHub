### Module
[教程地址：Module](http://javascript.ruanyifeng.com/nodejs/module.html)

---
### 目录
```
1. 概述
2. module对象
   2.1 module.exports属性
   2.2 exports变量
3. AMD规范与CommonJS规范的兼容性
4. require命令
   4.1 基本用法
   4.2 加载规则
   4.3 目录的加载规则
   4.4 模块的缓存
   4.5 环境变量NODE_PATH
   4.6 模块的循环加载
   4.7 require.main
5. 模块的加载机制
   5.1 require的内部处理流程
6. 参考链接
```

---
### 1. 概述
- Node应用由模块组成，采用CommonJS模块规范- 
- 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见
- 如果想在多个文件分享变量，必须定义为global对象的属性
- CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性
- CommonJS模块的特点如下
  *   所有代码都运行在模块作用域，不会污染全局作用域。
  *   模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
  *   模块加载的顺序，按照其在代码中出现的顺序

---
### 2.  module对象
- Node内部提供一个`Module`构建函数。所有模块都是`Module`的实例
- 每个模块内部，都有一个`module`对象，代表当前模块。它有以下属性
  *   `module.id` 模块的识别符，通常是带有绝对路径的模块文件名。
  *   `module.filename` 模块的文件名，带有绝对路径。
  *   `module.loaded` 返回一个布尔值，表示模块是否已经完成加载。
  *   `module.parent` 返回一个对象，表示调用该模块的模块。
  *   `module.children` 返回一个数组，表示该模块要用到的其他模块。
  *   `module.exports` 表示模块对外输出的值

- 利用这一点，可以判断当前模块是否为入口脚本

#### 2.1 module.exports属性
- `module.exports`属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取`module.exports`变量

#### 2.2 exports变量
- 为了方便，Node为每个模块提供一个exports变量，指向module.exports
- 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法
- 注意，不能直接将exports变量指向一个值，因为这样等于切断了`exports`与`module.exports`的联系
- 如果一个模块的对外接口，就是一个单一的值，不能使用`exports`输出，只能使用`module.exports`输出
- 如果你觉得，`exports`与`module.exports`之间的区别很难分清，一个简单的处理方法，就是放弃使用`exports`，只使用`module.exports`

---
### 3. AMD规范与CommonJS规范的兼容性
- CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数
- 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用
- 但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范
- AMD规范允许输出的模块兼容CommonJS规范

---
### 4.  require命令

#### 4.1 基本用法
- Node使用CommonJS模块规范，内置的`require`命令用于加载模块文件
- `require`命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错
- 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在`module.exports`变量上面

#### 4.2 加载规则
- `require`命令用于加载文件，后缀名默认为`.js`

#### 4.3 目录的加载规则
- 通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让`require`方法可以通过这个入口文件，加载整个目录

#### 4.4 模块的缓存
- 第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的`module.exports`属性
- 如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次`require`这个模块的时候，重新执行一下输出的函数
- 所有缓存的模块保存在`require.cache`之中

#### 4.5 环境变量NODE_PATH
- Node执行一个脚本时，会先查看环境变量`NODE_PATH`。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找

#### 4.6 模块的循环加载
>略

#### 4.7 require.main
- `require`方法有一个`main`属性，可以用来判断模块是直接执行，还是被调用执行

---
### 5. 模块的加载机制
- CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值


#### 5.1 require的内部处理流程
- `require`命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的`module.require`命令，而后者又调用Node的内部命令`Module._load`
