### 概述
[教程地址：概述](http://javascript.ruanyifeng.com/nodejs/basic.html)

---
### 目录
```
1. 简介
   1.1 安装与更新
   1.2 版本管理工具nvm
   1.3 基本用法
   1.4 REPL环境
   1.5 异步操作
   1.6 全局对象和全局变量
2. 模块化结构
   2.1 概述
   2.2 核心模块
   2.3 自定义模块
3. 异常处理
   3.1 try…catch结构
   3.2 回调函数
   3.3 EventEmitter接口的error事件
   3.4 uncaughtException事件
   3.5 unhandledRejection事件
4. 命令行脚本
5. 参考链接
```

---
### 1. 简介
- Node是JavaScript语言的服务器运行环境
- 所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机
- 其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库
- Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源

#### 1.1 安装与更新
>略

#### 1.2 版本管理工具nvm
- 如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm

#### 1.3 基本用法
- 安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本

#### 1.4 REPL环境
- 在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，”读取-求值-输出”循环），可以直接运行各种JavaScript命令

#### 1.5 异步操作
- Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行
- 由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义
- Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象
- Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数
- 如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误

#### 1.6 全局对象和全局变量
- Node提供以下几个全局对象，它们是所有模块都可以调用的
  - global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到
  - process：该对象表示Node所处的当前进程，允许开发者与该进程互动
  - console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能

- Node还提供一些全局函数
  - **setTimeout()**：用于在指定毫秒之后，运行回调函数
  - **clearTimeout()**：用于终止一个setTimeout方法新建的定时器
  - **setInterval()**：用于每隔一定毫秒调用回调函数
  - **clearInterval()**：终止一个用setInterval方法新建的定时器
  - **require()**：用于加载模块
  - **Buffer()**：用于操作二进制数据

- Node提供两个全局变量，都以两个下划线开头
  - `__filename`：指向当前运行的脚本文件名
  - `__dirname`：指向当前运行的脚本所在的目录

---
### 2.  模块化结构

#### 2.1 概述
- Node.js采用模块化结构，按照[CommonJS规范](http://wiki.commonjs.org/wiki/CommonJS)定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件
- require命令用于指定加载模块，加载时可以省略脚本文件的后缀名
- require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块
- 有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件
- 如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载
- 模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数

#### 2.2 核心模块
- 如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单
  *   **http**：提供HTTP服务器功能。
  *   **url**：解析URL。
  *   **fs**：与文件系统交互。
  *   **querystring**：解析URL的查询字符串。
  *   **child_process**：新建子进程。
  *   **util**：提供一系列实用小工具。
  *   **path**：处理文件路径。
  *   **crypto**：提供加密和解密功能，基本上是对OpenSSL的包装

#### 2.3 自定义模块
- Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块
- module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口
- 如果直接输出一个函数，那么调用模块就是调用一个函数。但是，模块也可以输出一个对象

---
### 3. 异常处理
- Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要
- 一般来说，Node有三种方法，传播一个错误
  *   使用throw语句抛出一个错误对象，即抛出异常。
  *   将错误对象传递给回调函数，由回调函数负责发出错误。
  *   通过EventEmitter接口，发出一个error事件

#### 3.1 try…catch结构
- 最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常
- 一般来说，Node只在很少场合才用try/catch语句，比如使用`JSON.parse`解析JSON文本

#### 3.2 回调函数
- ode采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题

#### 3.3 EventEmitter接口的error事件
- 发生错误的时候，也可以用EventEmitter接口抛出error事件

#### 3.4 uncaughtException事件
- 当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常
- 当uncaughtException触发后，最好记录错误日志，然后结束Node进程

#### 3.5 unhandledRejection事件
- iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态

---
### 4. ## 命令行脚本
