### 2.7 函数
[教程地址： 2.7 函数](http://javascript.ruanyifeng.com/grammar/function.html)

---
### 目录
```
1. 概述
   1.1 函数的声明
   1.2 函数的重复声明
   1.3 圆括号运算符，return语句和递归
   1.4 第一等公民
   1.5 函数名的提升
   1.6 不能在条件语句中声明函数
2. 函数的属性和方法
   2.1 name属性
   2.2 length属性
   2.3 toString()
3. 函数作用域
   3.1 定义
   3.2 函数内部的变量提升
   3.3 函数本身的作用域
4. 参数
   4.1 概述
   4.2 参数的省略
   4.3 默认值
   4.4 传递方式
   4.5 同名参数
   4.6 arguments对象
5. 函数的其他知识点
   5.1 闭包
   5.2 立即调用的函数表达式（IIFE）
6. eval命令
7. 参考链接
```

---
### 1. 概述

#### 1.1 函数的声明
- `function`命令声明的代码区块，就是一个函数
- 除了用`function`命令声明函数，还可以采用变量赋值的写法
- 采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效
- 这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
- 还有第三种声明函数的方式：`Function`构造函数
- `Function`构造函数可以不使用`new`命令，返回结果完全一样。总的来说，这种声明函数的方式非常不直观，几乎无人使用

#### 1.2 函数的重复申明
- 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明
- 函数名也可以提升

#### 1.3  圆括号运算符，return语句和递归
- `return`语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回`undefined`
- 函数可以调用自身，这就是递归（recursion）

#### 1.4 第一等公民
- JavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。
- 凡是可以使用值的地方，就能使用函数

#### 1.5 函数名的提升
- JavaScript引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部
- 如果同时采用`function`命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义

#### 1.6 不能在条件语句中声明函数
- 根据ECMAScript的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句
- 但是由于存在函数名的提升，所以在条件语句中声明函数，可能是无效的，这是非常容易出错的地方
- 要达到在条件语句中定义函数的目的，只有使用函数表达式

---
### 2. 函数的属性和方法

#### 2.1 name属性
- `name`属性返回紧跟在`function`关键字之后的那个函数名

```
function f1() {}
f1.name // 'f1'

var f2 = function () {};
f2.name // ''

var f3 = function myName() {};
f3.name // 'myName'
```

#### 2.2 length属性
- `length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数
- `length`属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）

#### 2.3 toString()
- 函数的`toString`方法返回函数的源码

---
### 3. 函数的作用域

#### 3.1 定义
- Javascript只有两种作用域：
   - 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取
   - 另一种是函数作用域，变量只在函数内部存在

- 在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取

- 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）

- 注意，对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量

#### 3.2 函数内部的变量提升
- 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部

#### 3.3  函数本身的作用域
- 函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关

- 函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域

---
### 4. 参数

#### 4.1 概述
#### 4.2 参数的省略
#### 4.3 默认值
#### 4. 传递方式
- 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部

- 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值

- 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值

#### 4.5 同名参数
- 如果有同名的参数，则取最后出现的那个值

#### 4.6  arguments对象
- `arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用

-`arguments`对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）

-可以通过`arguments`对象的`length`属性，判断函数调用时到底带几个参数

-需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用

---
### 5. 函数的其他知识点

#### 5.1 闭包
- 在函数外部无法读取函数内部声明的变量
- 由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”
- 闭包最大的特点，就是它可以“记住”诞生的环境
- 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁
- 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在
- 闭包的另一个用处，是封装对象的私有属性和私有方法
- 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题

#### 5.2 立即调用的函数表达式（IIFE）
- 有时，我们需要在定义函数之后，立即调用该函数
- 为了避免解析上的歧义，JavaScript引擎规定，如果`function`关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了
- 解决方法就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面（即实现立即调用，又出现在行首）（最后的分号都是必须的）
- 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量

```
(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();
```

---
### 6. eval命令
- `eval`命令的作用是，将字符串当作语句执行
- `eval`没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题
- 为了防止这种风险，JavaScript规定，如果使用严格模式，`eval`内部声明的变量，不会影响到外部作用域
- 不过，即使在严格模式下，`eval`依然可以读写当前作用域的变量
- 此外，`eval`的命令字符串不会得到JavaScript引擎的优化，运行速度较慢。这也是一个不应该使用它的理由
- 通常情况下，`eval`最常见的场合是解析JSON数据字符串，不过正确的做法应该是使用浏览器提供的`JSON.parse`方法
